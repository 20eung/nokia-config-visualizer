import { useState, useRef, useMemo } from 'react';
import Sparkles from 'lucide-react/dist/esm/icons/sparkles';
import X from 'lucide-react/dist/esm/icons/x';
import Plus from 'lucide-react/dist/esm/icons/plus';
import Trash2 from 'lucide-react/dist/esm/icons/trash-2';
import ArrowUp from 'lucide-react/dist/esm/icons/arrow-up';
import ArrowDown from 'lucide-react/dist/esm/icons/arrow-down';
import Eraser from 'lucide-react/dist/esm/icons/eraser';
import RotateCcw from 'lucide-react/dist/esm/icons/rotate-ccw';
import type { ParsedConfigV3 } from '../../utils/v3/parserV3';
import type { NameDictionary, DictionaryEntry } from '../../types/dictionary';
import { getUniqueDescriptions } from '../../utils/descriptionExtractor';
import { createEmptyDictionary } from '../../utils/dictionaryStorage';
import { generateDictionary, saveDictionaryToServer } from '../../services/dictionaryApi';

import './DictionaryEditor.css';

interface DictionaryEditorProps {
  configs: ParsedConfigV3[];
  dictionary: NameDictionary | null;
  onSave: (dictionary: NameDictionary) => void;
  onClose: () => void;
}

let nextLocalId = 1;

function makeId(): string {
  return `entry-${Date.now()}-${nextLocalId++}`;
}

type SortField = 'name' | 'configKeywords' | 'searchAliases';
type SortDir = 'asc' | 'desc';

export function DictionaryEditor({
  configs,
  dictionary,
  onSave,
  onClose,
}: DictionaryEditorProps) {
  const [entries, setEntries] = useState<DictionaryEntry[]>(
    dictionary?.entries ?? [],
  );
  // 검색 별칭 필드의 raw 문자열을 entry.id별로 관리 (줄바꿈으로 구분)
  const [aliasTexts, setAliasTexts] = useState<Record<string, string>>(() => {
    const init: Record<string, string> = {};
    for (const e of dictionary?.entries ?? []) {
      init[e.id] = e.searchAliases.join('\n');
    }
    return init;
  });
  // Config 키워드 필드의 raw 문자열을 entry.id별로 관리 (줄바꿈으로 구분)
  const [keywordTexts, setKeywordTexts] = useState<Record<string, string>>(() => {
    const init: Record<string, string> = {};
    for (const e of dictionary?.entries ?? []) {
      init[e.id] = e.configKeywords.join('\n');
    }
    return init;
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);
  const [sortField, setSortField] = useState<SortField | null>(null);
  const [sortDir, setSortDir] = useState<SortDir>('asc');

  const toggleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDir(prev => (prev === 'asc' ? 'desc' : 'asc'));
    } else {
      setSortField(field);
      setSortDir('asc');
    }
  };

  const sortedEntries = useMemo(() => {
    if (!sortField) return entries;
    return [...entries].sort((a, b) => {
      let va: string;
      let vb: string;
      if (sortField === 'searchAliases') {
        va = (aliasTexts[a.id] ?? a.searchAliases.join('\n')).toLowerCase();
        vb = (aliasTexts[b.id] ?? b.searchAliases.join('\n')).toLowerCase();
      } else if (sortField === 'configKeywords') {
        va = (keywordTexts[a.id] ?? a.configKeywords.join('\n')).toLowerCase();
        vb = (keywordTexts[b.id] ?? b.configKeywords.join('\n')).toLowerCase();
      } else {
        va = String(a[sortField]).toLowerCase();
        vb = String(b[sortField]).toLowerCase();
      }
      const cmp = va.localeCompare(vb, 'ko');
      return sortDir === 'asc' ? cmp : -cmp;
    });
  }, [entries, aliasTexts, keywordTexts, sortField, sortDir]);

  const handleGenerate = async () => {
    const descriptions = getUniqueDescriptions(configs);
    if (descriptions.length === 0) {
      setError('추출할 description이 없습니다.');
      return;
    }

    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);
    setError(null);

    try {
      const result = await generateDictionary(descriptions, controller.signal);

      // 기존 항목 모두 보존, 새 그룹명만 추가
      const existingNames = new Set(entries.map(e => e.name));

      const newEntries: DictionaryEntry[] = result.entries
        .filter(e => !existingNames.has(e.name))
        .map(e => {
          return {
            id: makeId(),
            name: e.name,
            configKeywords: e.configKeywords,
            searchAliases: e.searchAliases,
            autoGenerated: true,
            userEdited: false,
          };
        });

      const allEntries = [...entries, ...newEntries];
      setEntries(allEntries);
      // aliasTexts, keywordTexts 동기화 (새 항목만 추가)
      const newAliasTexts: Record<string, string> = { ...aliasTexts };
      const newKeywordTexts: Record<string, string> = { ...keywordTexts };
      for (const e of newEntries) {
        newAliasTexts[e.id] = e.searchAliases.join('\n');
        newKeywordTexts[e.id] = e.configKeywords.join('\n');
      }
      setAliasTexts(newAliasTexts);
      setKeywordTexts(newKeywordTexts);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.';
      setError(message);
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    // 저장 시 aliasTexts, keywordTexts → entries 동기화
    const finalEntries = entries.map(e => ({
      ...e,
      configKeywords: (keywordTexts[e.id] ?? e.configKeywords.join('\n'))
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean),
      searchAliases: (aliasTexts[e.id] ?? e.searchAliases.join('\n'))
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean),
    }));

    const dict: NameDictionary = dictionary
      ? { ...dictionary, entries: finalEntries, updatedAt: new Date().toISOString() }
      : { ...createEmptyDictionary(), entries: finalEntries };

    const ok = await saveDictionaryToServer(dict);
    if (!ok) {
      setError('사전 저장에 실패했습니다. 서버 연결을 확인해주세요.');
      return;
    }
    onSave(dict);
    onClose();
  };

  const handleAddEntry = () => {
    const id = makeId();
    setEntries(prev => [
      ...prev,
      {
        id,
        name: '',
        configKeywords: [],
        searchAliases: [],
        autoGenerated: false,
        userEdited: true,
      },
    ]);
    setAliasTexts(prev => ({ ...prev, [id]: '' }));
    setKeywordTexts(prev => ({ ...prev, [id]: '' }));
  };

  const handleDeleteEntry = (id: string) => {
    setEntries(prev => prev.filter(e => e.id !== id));
    setAliasTexts(prev => {
      const next = { ...prev };
      delete next[id];
      return next;
    });
    setKeywordTexts(prev => {
      const next = { ...prev };
      delete next[id];
      return next;
    });
  };

  const handleDedup = () => {
    console.log('[항목 병합] 시작... 현재 항목 수:', entries.length);

    // Step 1: 각 항목의 모든 이름 수집 (name, configKeywords, searchAliases)
    const getAllNames = (e: DictionaryEntry): Set<string> => {
      const names = new Set<string>();
      const aliasRaw = aliasTexts[e.id] ?? e.searchAliases.join('\n');
      const aliases = aliasRaw.split('\n').map(s => s.trim()).filter(a => a !== '');

      if (e.name) names.add(e.name.toLowerCase().trim());
      e.configKeywords.forEach(k => {
        const normalized = k.toLowerCase().trim();
        if (normalized) names.add(normalized);
      });
      aliases.forEach(a => {
        const normalized = a.toLowerCase().trim();
        if (normalized) names.add(normalized);
      });

      return names;
    };

    // 디버깅: 각 항목의 이름 출력
    console.log('[항목 병합] 각 항목의 이름:');
    for (const e of entries) {
      const names = getAllNames(e);
      console.log(`  - ${e.name}: [${Array.from(names).join(', ')}]`);
    }

    // Step 2: Union-Find를 사용하여 연결된 항목 그룹 찾기
    const parent = new Map<string, string>(); // entry.id -> parent entry.id
    const find = (id: string): string => {
      if (!parent.has(id)) {
        parent.set(id, id);
        return id;
      }
      if (parent.get(id) === id) return id;
      const root = find(parent.get(id)!);
      parent.set(id, root);
      return root;
    };
    const union = (id1: string, id2: string) => {
      const root1 = find(id1);
      const root2 = find(id2);
      if (root1 !== root2) {
        parent.set(root2, root1);
      }
    };

    // Step 3: 이름이 겹치는 항목들을 연결
    const nameToEntryIds = new Map<string, string[]>();
    for (const e of entries) {
      const names = getAllNames(e);
      for (const name of names) {
        if (!nameToEntryIds.has(name)) {
          nameToEntryIds.set(name, []);
        }
        nameToEntryIds.get(name)!.push(e.id);
      }
    }

    // 디버깅: 공유된 이름 출력
    console.log('[항목 병합] 공유된 이름:');
    let sharedCount = 0;
    for (const [name, entryIds] of nameToEntryIds.entries()) {
      if (entryIds.length > 1) {
        sharedCount++;
        const names = entryIds.map(id => entries.find(e => e.id === id)?.name || '?').join(', ');
        console.log(`  - "${name}" → [${names}]`);
      }
    }
    console.log(`[항목 병합] 공유된 이름 총 ${sharedCount}개`);

    // 같은 이름을 공유하는 항목들을 union
    for (const entryIds of nameToEntryIds.values()) {
      if (entryIds.length > 1) {
        for (let i = 1; i < entryIds.length; i++) {
          union(entryIds[0], entryIds[i]);
        }
      }
    }

    // Step 4: 그룹별로 항목 수집
    const groups = new Map<string, string[]>(); // root id -> [entry ids]
    for (const e of entries) {
      const root = find(e.id);
      if (!groups.has(root)) {
        groups.set(root, []);
      }
      groups.get(root)!.push(e.id);
    }

    // 디버깅: 그룹 정보 출력
    console.log('[항목 병합] 그룹 정보:');
    for (const [, groupIds] of groups.entries()) {
      const names = groupIds.map(id => entries.find(e => e.id === id)?.name || '?');
      if (groupIds.length > 1) {
        console.log(`  - 그룹 (${groupIds.length}개): [${names.join(', ')}]`);
      } else {
        console.log(`  - 단독: ${names[0]}`);
      }
    }

    // Step 5: 각 그룹을 하나의 항목으로 병합
    const mergedEntries: DictionaryEntry[] = [];
    let mergeCount = 0;

    for (const [rootId, groupIds] of groups.entries()) {
      if (groupIds.length === 1) {
        // 병합 불필요 → 기존 항목 유지
        const e = entries.find(e => e.id === rootId)!;
        mergedEntries.push(e);
        continue;
      }

      mergeCount++;

      // 그룹 내 모든 이름 수집
      const allNames = new Set<string>();
      const allConfigKeywords = new Set<string>();
      const groupEntries = groupIds.map(id => entries.find(e => e.id === id)!);

      for (const e of groupEntries) {
        const names = getAllNames(e);
        for (const name of names) {
          allNames.add(name);
        }
        e.configKeywords.forEach(k => {
          if (k.trim()) allConfigKeywords.add(k.trim());
        });
      }

      // 대표 항목 선정 (가장 긴 name을 가진 항목)
      let representative = groupEntries[0];
      for (const e of groupEntries) {
        if (e.name.length > representative.name.length) {
          representative = e;
        }
      }

      // 대표 항목의 name을 allNames에서 제거하여 searchAliases만 남김
      allNames.delete(representative.name.toLowerCase().trim());

      // 병합된 항목 생성
      const mergedEntry: DictionaryEntry = {
        ...representative,
        configKeywords: Array.from(allConfigKeywords),
        searchAliases: Array.from(allNames).filter(n => n !== ''),
        userEdited: true,
      };

      mergedEntries.push(mergedEntry);

      console.log(`[항목 병합] ${groupIds.length}개 항목 통합: ${groupEntries.map(e => e.name).join(', ')} → ${representative.name}`);
    }

    setEntries(mergedEntries);
    const newAliasTexts: Record<string, string> = {};
    const newKeywordTexts: Record<string, string> = {};
    for (const e of mergedEntries) {
      newAliasTexts[e.id] = e.searchAliases.join('\n');
      newKeywordTexts[e.id] = e.configKeywords.join('\n');
    }
    setAliasTexts(newAliasTexts);
    setKeywordTexts(newKeywordTexts);

    if (mergeCount > 0) {
      console.log(`[항목 병합] 총 ${mergeCount}개 그룹 병합 완료`);
    } else {
      console.log('[항목 병합] 병합 대상 없음');
    }
  };

  const handleClearAll = () => {
    setEntries([]);
    setAliasTexts({});
    setKeywordTexts({});
  };

  const updateEntry = (id: string, field: keyof DictionaryEntry, value: string | string[]) => {
    setEntries(prev =>
      prev.map(e =>
        e.id === id ? { ...e, [field]: value, userEdited: true } : e
      ),
    );
  };

  return (
    <div className="dict-overlay" onClick={onClose}>
      <div className="dict-modal" onClick={e => e.stopPropagation()}>
        {/* Header */}
        <div className="dict-header">
          <h2>이름 사전 (Name Dictionary) - v{__APP_VERSION__}</h2>
          <div className="dict-header-actions">
            <button
              className="dict-generate-btn"
              onClick={handleGenerate}
              disabled={loading}
            >
              <Sparkles size={16} />
              AI 자동 생성
            </button>
            <button className="dict-close-btn" onClick={onClose}>
              <X size={18} />
            </button>
          </div>
        </div>

        {/* Body */}
        <div className="dict-body">
          {error && <div className="dict-error">{error}</div>}

          {loading ? (
            <div className="dict-loading">
              <div className="dict-loading-spinner" />
              <span>AI가 이름 사전을 생성하고 있습니다...</span>
            </div>
          ) : entries.length === 0 ? (
            <div className="dict-empty">
              <p>아직 사전 항목이 없습니다.</p>
              <p>"AI 자동 생성" 버튼을 클릭하여 Config description에서 엔티티를 추출하세요.</p>
            </div>
          ) : (
            <table className="dict-table">
              <thead>
                <tr>
                  {([
                    ['name', '15%', '그룹명'],
                    ['configKeywords', '35%', 'Config 키워드 (줄바꿈으로 구분)'],
                    ['searchAliases', '45%', '검색 별칭 (줄바꿈으로 구분)'],
                  ] as const).map(([field, width, label]) => (
                    <th
                      key={field}
                      style={{ width, cursor: 'pointer' }}
                      className={sortField === field ? 'dict-th-active' : ''}
                      onClick={() => toggleSort(field)}
                    >
                      <span className="dict-th-content">
                        {label}
                        {sortField === field
                          ? (sortDir === 'asc' ? <ArrowUp size={12} /> : <ArrowDown size={12} />)
                          : null}
                      </span>
                    </th>
                  ))}
                  <th style={{ width: '5%' }}></th>
                </tr>
              </thead>
              <tbody>
                {sortedEntries.map(entry => (
                  <tr key={entry.id}>
                    <td>
                      <input
                        className="dict-input token"
                        value={entry.name}
                        onChange={e => updateEntry(entry.id, 'name', e.target.value)}
                      />
                    </td>
                    <td>
                      <textarea
                        className="dict-textarea"
                        rows={3}
                        value={keywordTexts[entry.id] ?? entry.configKeywords.join('\n')}
                        onChange={e =>
                          setKeywordTexts(prev => ({ ...prev, [entry.id]: e.target.value }))
                        }
                        placeholder="CompanyA&#10;EntA&#10;PartnerA&#10;SecA"
                      />
                    </td>
                    <td>
                      <textarea
                        className="dict-textarea"
                        rows={3}
                        value={aliasTexts[entry.id] ?? entry.searchAliases.join('\n')}
                        onChange={e =>
                          setAliasTexts(prev => ({ ...prev, [entry.id]: e.target.value }))
                        }
                        placeholder="고객사A&#10;엔터프라이즈A&#10;보안업체A&#10;파트너A"
                      />
                    </td>
                    <td>
                      <button
                        className="dict-delete-btn"
                        onClick={() => handleDeleteEntry(entry.id)}
                        title="삭제"
                      >
                        <Trash2 size={14} />
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>

        {/* Footer */}
        <div className="dict-footer">
          <div className="dict-footer-left">
            <button className="dict-add-btn" onClick={handleAddEntry}>
              <Plus size={14} />
              항목 추가
            </button>
            <button
              className="dict-add-btn"
              onClick={handleDedup}
              disabled={entries.length === 0}
              title="같은 이름을 공유하는 항목들을 하나로 병합"
            >
              <Eraser size={14} />
              항목 병합
            </button>
            <button
              className="dict-add-btn dict-clear-btn"
              onClick={handleClearAll}
              disabled={entries.length === 0}
            >
              <RotateCcw size={14} />
              전체 삭제
            </button>
          </div>
          <button className="dict-save-btn" onClick={handleSave}>
            저장
          </button>
        </div>
      </div>
    </div>
  );
}
