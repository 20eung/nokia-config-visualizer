import { useState, useRef, useMemo } from 'react';
import { Sparkles, X, Plus, Trash2, ArrowUp, ArrowDown, Eraser, RotateCcw } from 'lucide-react';
import type { ParsedConfigV3 } from '../../utils/v3/parserV3';
import type { NameDictionary, DictionaryEntry } from '../../types/dictionary';
import { getUniqueDescriptions } from '../../utils/descriptionExtractor';
import { createEmptyDictionary } from '../../utils/dictionaryStorage';
import { generateDictionary, saveDictionaryToServer } from '../../services/dictionaryApi';

import './DictionaryEditor.css';

interface DictionaryEditorProps {
  configs: ParsedConfigV3[];
  dictionary: NameDictionary | null;
  onSave: (dictionary: NameDictionary) => void;
  onClose: () => void;
}

let nextLocalId = 1;

function makeId(): string {
  return `entry-${Date.now()}-${nextLocalId++}`;
}

type EntryCategory = DictionaryEntry['category'];
const CATEGORIES: EntryCategory[] = ['customer', 'location', 'service', 'device', 'other'];

type SortField = 'originalToken' | 'category' | 'shortName' | 'longName' | 'koreanName' | 'aliases';
type SortDir = 'asc' | 'desc';

export function DictionaryEditor({
  configs,
  dictionary,
  onSave,
  onClose,
}: DictionaryEditorProps) {
  const [entries, setEntries] = useState<DictionaryEntry[]>(
    dictionary?.entries ?? [],
  );
  // 별칭 필드의 raw 문자열을 entry.id별로 관리 (입력 중 쉼표 유실 방지)
  const [aliasTexts, setAliasTexts] = useState<Record<string, string>>(() => {
    const init: Record<string, string> = {};
    for (const e of dictionary?.entries ?? []) {
      init[e.id] = e.aliases.join(', ');
    }
    return init;
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);
  const [sortField, setSortField] = useState<SortField | null>(null);
  const [sortDir, setSortDir] = useState<SortDir>('asc');

  const toggleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDir(prev => (prev === 'asc' ? 'desc' : 'asc'));
    } else {
      setSortField(field);
      setSortDir('asc');
    }
  };

  const sortedEntries = useMemo(() => {
    if (!sortField) return entries;
    return [...entries].sort((a, b) => {
      let va: string;
      let vb: string;
      if (sortField === 'aliases') {
        va = (aliasTexts[a.id] ?? a.aliases.join(', ')).toLowerCase();
        vb = (aliasTexts[b.id] ?? b.aliases.join(', ')).toLowerCase();
      } else {
        va = String(a[sortField]).toLowerCase();
        vb = String(b[sortField]).toLowerCase();
      }
      const cmp = va.localeCompare(vb, 'ko');
      return sortDir === 'asc' ? cmp : -cmp;
    });
  }, [entries, aliasTexts, sortField, sortDir]);

  const handleGenerate = async () => {
    const descriptions = getUniqueDescriptions(configs);
    if (descriptions.length === 0) {
      setError('추출할 description이 없습니다.');
      return;
    }

    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);
    setError(null);

    try {
      const result = await generateDictionary(descriptions, controller.signal);

      // 기존 항목 모두 보존, 새 토큰만 추가
      const existingTokens = new Set(entries.map(e => e.originalToken));

      const newEntries: DictionaryEntry[] = result.entries
        .filter(e => !existingTokens.has(e.originalToken))
        .map(e => {
          const token = e.originalToken;
          return {
            id: makeId(),
            originalToken: token,
            category: e.category,
            shortName: e.shortName === token ? '' : e.shortName,
            longName: e.longName === token ? '' : e.longName,
            koreanName: e.koreanName === token ? '' : e.koreanName,
            aliases: e.aliases.filter(a => a !== token),
            autoGenerated: true,
            userEdited: false,
          };
        });

      const allEntries = [...entries, ...newEntries];
      setEntries(allEntries);
      // aliasTexts 동기화 (새 항목만 추가)
      const newTexts: Record<string, string> = { ...aliasTexts };
      for (const e of newEntries) {
        newTexts[e.id] = e.aliases.join(', ');
      }
      setAliasTexts(newTexts);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.';
      setError(message);
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    // 저장 시 aliasTexts → entries.aliases 동기화
    const finalEntries = entries.map(e => ({
      ...e,
      aliases: (aliasTexts[e.id] ?? e.aliases.join(', '))
        .split(',')
        .map(s => s.trim())
        .filter(Boolean),
    }));

    const dict: NameDictionary = dictionary
      ? { ...dictionary, entries: finalEntries, updatedAt: new Date().toISOString() }
      : { ...createEmptyDictionary(), entries: finalEntries };

    const ok = await saveDictionaryToServer(dict);
    if (!ok) {
      setError('사전 저장에 실패했습니다. 서버 연결을 확인해주세요.');
      return;
    }
    onSave(dict);
    onClose();
  };

  const handleAddEntry = () => {
    const id = makeId();
    setEntries(prev => [
      ...prev,
      {
        id,
        originalToken: '',
        category: 'other',
        shortName: '',
        longName: '',
        koreanName: '',
        aliases: [],
        autoGenerated: false,
        userEdited: true,
      },
    ]);
    setAliasTexts(prev => ({ ...prev, [id]: '' }));
  };

  const handleDeleteEntry = (id: string) => {
    setEntries(prev => prev.filter(e => e.id !== id));
    setAliasTexts(prev => {
      const next = { ...prev };
      delete next[id];
      return next;
    });
  };

  const handleDedup = () => {
    const cleaned = entries.map(e => {
      const token = e.originalToken;
      if (!token) return e;
      const aliasRaw = aliasTexts[e.id] ?? e.aliases.join(', ');
      const cleanedAliases = aliasRaw
        .split(',')
        .map(s => s.trim())
        .filter(a => a !== '' && a !== token);
      return {
        ...e,
        shortName: e.shortName === token ? '' : e.shortName,
        longName: e.longName === token ? '' : e.longName,
        koreanName: e.koreanName === token ? '' : e.koreanName,
        aliases: cleanedAliases,
        userEdited: true,
      };
    });
    setEntries(cleaned);
    const newTexts: Record<string, string> = {};
    for (const e of cleaned) {
      newTexts[e.id] = e.aliases.join(', ');
    }
    setAliasTexts(newTexts);
  };

  const handleClearAll = () => {
    setEntries([]);
    setAliasTexts({});
  };

  const updateEntry = (id: string, field: keyof DictionaryEntry, value: string | string[]) => {
    setEntries(prev =>
      prev.map(e =>
        e.id === id ? { ...e, [field]: value, userEdited: true } : e
      ),
    );
  };

  return (
    <div className="dict-overlay" onClick={onClose}>
      <div className="dict-modal" onClick={e => e.stopPropagation()}>
        {/* Header */}
        <div className="dict-header">
          <h2>이름 사전 (Name Dictionary)</h2>
          <div className="dict-header-actions">
            <button
              className="dict-generate-btn"
              onClick={handleGenerate}
              disabled={loading}
            >
              <Sparkles size={16} />
              AI 자동 생성
            </button>
            <button className="dict-close-btn" onClick={onClose}>
              <X size={18} />
            </button>
          </div>
        </div>

        {/* Body */}
        <div className="dict-body">
          {error && <div className="dict-error">{error}</div>}

          {loading ? (
            <div className="dict-loading">
              <div className="dict-loading-spinner" />
              <span>AI가 이름 사전을 생성하고 있습니다...</span>
            </div>
          ) : entries.length === 0 ? (
            <div className="dict-empty">
              <p>아직 사전 항목이 없습니다.</p>
              <p>"AI 자동 생성" 버튼을 클릭하여 Config description에서 엔티티를 추출하세요.</p>
            </div>
          ) : (
            <table className="dict-table">
              <thead>
                <tr>
                  {([
                    ['originalToken', '15%', '원본 토큰'],
                    ['category', '10%', '카테고리'],
                    ['shortName', '14%', '짧은 이름'],
                    ['longName', '18%', '긴 이름'],
                    ['koreanName', '14%', '한국어'],
                    ['aliases', '24%', '별칭 (쉼표 구분)'],
                  ] as const).map(([field, width, label]) => (
                    <th
                      key={field}
                      style={{ width, cursor: 'pointer' }}
                      className={sortField === field ? 'dict-th-active' : ''}
                      onClick={() => toggleSort(field)}
                    >
                      <span className="dict-th-content">
                        {label}
                        {sortField === field
                          ? (sortDir === 'asc' ? <ArrowUp size={12} /> : <ArrowDown size={12} />)
                          : null}
                      </span>
                    </th>
                  ))}
                  <th style={{ width: '5%' }}></th>
                </tr>
              </thead>
              <tbody>
                {sortedEntries.map(entry => (
                  <tr key={entry.id}>
                    <td>
                      <input
                        className="dict-input token"
                        value={entry.originalToken}
                        onChange={e => updateEntry(entry.id, 'originalToken', e.target.value)}
                      />
                    </td>
                    <td>
                      <select
                        className="dict-select"
                        value={entry.category}
                        onChange={e => updateEntry(entry.id, 'category', e.target.value)}
                      >
                        {CATEGORIES.map(c => (
                          <option key={c} value={c}>{c}</option>
                        ))}
                      </select>
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={entry.shortName}
                        onChange={e => updateEntry(entry.id, 'shortName', e.target.value)}
                      />
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={entry.longName}
                        onChange={e => updateEntry(entry.id, 'longName', e.target.value)}
                      />
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={entry.koreanName}
                        onChange={e => updateEntry(entry.id, 'koreanName', e.target.value)}
                      />
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={aliasTexts[entry.id] ?? entry.aliases.join(', ')}
                        onChange={e =>
                          setAliasTexts(prev => ({ ...prev, [entry.id]: e.target.value }))
                        }
                      />
                    </td>
                    <td>
                      <button
                        className="dict-delete-btn"
                        onClick={() => handleDeleteEntry(entry.id)}
                        title="삭제"
                      >
                        <Trash2 size={14} />
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>

        {/* Footer */}
        <div className="dict-footer">
          <div className="dict-footer-left">
            <button className="dict-add-btn" onClick={handleAddEntry}>
              <Plus size={14} />
              항목 추가
            </button>
            <button
              className="dict-add-btn"
              onClick={handleDedup}
              disabled={entries.length === 0}
              title="원본 토큰과 동일한 값을 짧은이름/긴이름/한국어/별칭에서 제거"
            >
              <Eraser size={14} />
              중복 정리
            </button>
            <button
              className="dict-add-btn dict-clear-btn"
              onClick={handleClearAll}
              disabled={entries.length === 0}
            >
              <RotateCcw size={14} />
              전체 삭제
            </button>
          </div>
          <button className="dict-save-btn" onClick={handleSave}>
            저장
          </button>
        </div>
      </div>
    </div>
  );
}
