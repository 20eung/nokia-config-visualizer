import { useState, useRef } from 'react';
import { Sparkles, X, Plus, Trash2 } from 'lucide-react';
import type { ParsedConfigV3 } from '../../utils/v3/parserV3';
import type { NameDictionary, DictionaryEntry } from '../../types/dictionary';
import { getUniqueDescriptions } from '../../utils/descriptionExtractor';
import { createEmptyDictionary } from '../../utils/dictionaryStorage';
import { generateDictionary, saveDictionaryToServer } from '../../services/dictionaryApi';
import './DictionaryEditor.css';

interface DictionaryEditorProps {
  configs: ParsedConfigV3[];
  configFingerprint: string;
  dictionary: NameDictionary | null;
  onSave: (dictionary: NameDictionary) => void;
  onClose: () => void;
}

let nextLocalId = 1;

function makeId(): string {
  return `entry-${Date.now()}-${nextLocalId++}`;
}

type EntryCategory = DictionaryEntry['category'];
const CATEGORIES: EntryCategory[] = ['customer', 'location', 'service', 'device', 'other'];

export function DictionaryEditor({
  configs,
  configFingerprint,
  dictionary,
  onSave,
  onClose,
}: DictionaryEditorProps) {
  const [entries, setEntries] = useState<DictionaryEntry[]>(
    dictionary?.entries ?? [],
  );
  // 별칭 필드의 raw 문자열을 entry.id별로 관리 (입력 중 쉼표 유실 방지)
  const [aliasTexts, setAliasTexts] = useState<Record<string, string>>(() => {
    const init: Record<string, string> = {};
    for (const e of dictionary?.entries ?? []) {
      init[e.id] = e.aliases.join(', ');
    }
    return init;
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const handleGenerate = async () => {
    const descriptions = getUniqueDescriptions(configs);
    if (descriptions.length === 0) {
      setError('추출할 description이 없습니다.');
      return;
    }

    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);
    setError(null);

    try {
      const result = await generateDictionary(descriptions, controller.signal);

      // 기존 userEdited 엔트리 보존
      const userEdited = entries.filter(e => e.userEdited);
      const userEditedTokens = new Set(userEdited.map(e => e.originalToken));

      const generated: DictionaryEntry[] = result.entries
        .filter(e => !userEditedTokens.has(e.originalToken))
        .map(e => ({
          id: makeId(),
          originalToken: e.originalToken,
          category: e.category,
          shortName: e.shortName,
          longName: e.longName,
          koreanName: e.koreanName,
          aliases: e.aliases,
          autoGenerated: true,
          userEdited: false,
        }));

      const allEntries = [...userEdited, ...generated];
      setEntries(allEntries);
      // aliasTexts 동기화
      const newTexts: Record<string, string> = {};
      for (const e of allEntries) {
        newTexts[e.id] = aliasTexts[e.id] ?? e.aliases.join(', ');
      }
      setAliasTexts(newTexts);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.';
      setError(message);
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    // 저장 시 aliasTexts → entries.aliases 동기화
    const finalEntries = entries.map(e => ({
      ...e,
      aliases: (aliasTexts[e.id] ?? e.aliases.join(', '))
        .split(',')
        .map(s => s.trim())
        .filter(Boolean),
    }));

    const dict: NameDictionary = dictionary
      ? { ...dictionary, entries: finalEntries, updatedAt: new Date().toISOString() }
      : { ...createEmptyDictionary(configFingerprint), entries: finalEntries };

    const ok = await saveDictionaryToServer(configFingerprint, dict);
    if (!ok) {
      setError('사전 저장에 실패했습니다. 서버 연결을 확인해주세요.');
      return;
    }
    onSave(dict);
    onClose();
  };

  const handleAddEntry = () => {
    const id = makeId();
    setEntries(prev => [
      ...prev,
      {
        id,
        originalToken: '',
        category: 'other',
        shortName: '',
        longName: '',
        koreanName: '',
        aliases: [],
        autoGenerated: false,
        userEdited: true,
      },
    ]);
    setAliasTexts(prev => ({ ...prev, [id]: '' }));
  };

  const handleDeleteEntry = (id: string) => {
    setEntries(prev => prev.filter(e => e.id !== id));
    setAliasTexts(prev => {
      const next = { ...prev };
      delete next[id];
      return next;
    });
  };

  const updateEntry = (id: string, field: keyof DictionaryEntry, value: string | string[]) => {
    setEntries(prev =>
      prev.map(e =>
        e.id === id ? { ...e, [field]: value, userEdited: true } : e
      ),
    );
  };

  return (
    <div className="dict-overlay" onClick={onClose}>
      <div className="dict-modal" onClick={e => e.stopPropagation()}>
        {/* Header */}
        <div className="dict-header">
          <h2>이름 사전 (Name Dictionary)</h2>
          <div className="dict-header-actions">
            <button
              className="dict-generate-btn"
              onClick={handleGenerate}
              disabled={loading}
            >
              <Sparkles size={16} />
              AI 자동 생성
            </button>
            <button className="dict-close-btn" onClick={onClose}>
              <X size={18} />
            </button>
          </div>
        </div>

        {/* Body */}
        <div className="dict-body">
          {error && <div className="dict-error">{error}</div>}

          {loading ? (
            <div className="dict-loading">
              <div className="dict-loading-spinner" />
              <span>AI가 이름 사전을 생성하고 있습니다...</span>
            </div>
          ) : entries.length === 0 ? (
            <div className="dict-empty">
              <p>아직 사전 항목이 없습니다.</p>
              <p>"AI 자동 생성" 버튼을 클릭하여 Config description에서 엔티티를 추출하세요.</p>
            </div>
          ) : (
            <table className="dict-table">
              <thead>
                <tr>
                  <th style={{ width: '15%' }}>원본 토큰</th>
                  <th style={{ width: '10%' }}>카테고리</th>
                  <th style={{ width: '14%' }}>짧은 이름</th>
                  <th style={{ width: '18%' }}>긴 이름</th>
                  <th style={{ width: '14%' }}>한국어</th>
                  <th style={{ width: '24%' }}>별칭 (쉼표 구분)</th>
                  <th style={{ width: '5%' }}></th>
                </tr>
              </thead>
              <tbody>
                {entries.map(entry => (
                  <tr key={entry.id}>
                    <td>
                      <input
                        className="dict-input token"
                        value={entry.originalToken}
                        onChange={e => updateEntry(entry.id, 'originalToken', e.target.value)}
                      />
                    </td>
                    <td>
                      <select
                        className="dict-select"
                        value={entry.category}
                        onChange={e => updateEntry(entry.id, 'category', e.target.value)}
                      >
                        {CATEGORIES.map(c => (
                          <option key={c} value={c}>{c}</option>
                        ))}
                      </select>
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={entry.shortName}
                        onChange={e => updateEntry(entry.id, 'shortName', e.target.value)}
                      />
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={entry.longName}
                        onChange={e => updateEntry(entry.id, 'longName', e.target.value)}
                      />
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={entry.koreanName}
                        onChange={e => updateEntry(entry.id, 'koreanName', e.target.value)}
                      />
                    </td>
                    <td>
                      <input
                        className="dict-input"
                        value={aliasTexts[entry.id] ?? entry.aliases.join(', ')}
                        onChange={e =>
                          setAliasTexts(prev => ({ ...prev, [entry.id]: e.target.value }))
                        }
                      />
                    </td>
                    <td>
                      <button
                        className="dict-delete-btn"
                        onClick={() => handleDeleteEntry(entry.id)}
                        title="삭제"
                      >
                        <Trash2 size={14} />
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>

        {/* Footer */}
        <div className="dict-footer">
          <button className="dict-add-btn" onClick={handleAddEntry}>
            <Plus size={14} />
            항목 추가
          </button>
          <button className="dict-save-btn" onClick={handleSave}>
            저장
          </button>
        </div>
      </div>
    </div>
  );
}
